# Copyright (C) 2017- Shigeru Chiba.  All rights reserved.

require 'ffi'

module Yadriggy
  module Oops

    # @abstract
    # A wrapper of memory object accessible from Ruby and C++ code.
    #
    class FFIArray
      # @return [FFI::MemoryPointer] the object holding all data.
      def memory_pointer()
        @array
      end

      def ==(obj)
        obj.is_a?(FFIArray) && @array == obj.memory_pointer
      end

      # Obtains the size.
      # @return [Integer] the number of elements.
      def size
        @array.size / @array.type_size
      end

      # Obtain the size.
      # @return [Integer] the number of elements.
      def length() size() end

      # Initializes the element values.
      def set_values
        size.times {|i| self[i] = yield i }
      end

      # Converts all the elements into an array.
      # This method is available only within Ruby.
      def to_a(*args, &proc)
        Array.new(size) {|i| self[i] }
      end

      # Obtain the element type.
      # All the subclasses have to override this method.
      def self.element_type()
        Undef
      end
    end

    # Array of 64bit integers.
    # In C++, the type of this array is `arrayof(Int)`.
    #
    class IntArray < FFIArray
      # @param [Integer] size  array size.
      # @param [FFI::MemoryPointer] ptr  a memory pointer or nil.
      #   If nil, a new memory block is allocated.
      def initialize(size, ptr=nil)
        if ptr.nil?
          @array = FFI::MemoryPointer.new(:int64, size)
        else
          @array = ptr
        end
      end

      def [](index)
        @array.get_int64(index * 8)
      end

      def []=(index, value)
        @array.put_int64(index * 8, value)
      end

      def self.element_type()
        Integer
      end
    end

    # Array of 64bit floating point numbers.
    # In C++, the type of this array is `arrayof(Float)`.
    #
    class FloatArray < FFIArray
      # @param [Integer] size  array size.
      # @param [FFI::MemoryPointer] ptr  a memory pointer or nil.
      #   If nil, a new memory block is allocated.
      def initialize(size, ptr=nil)
        if ptr.nil?
          @array = FFI::MemoryPointer.new(:double, size)
        else
          @array = ptr
        end
      end

      def [](index)
        @array.get_float64(index * 8)
      end

      def []=(index, value)
        @array.put_float64(index * 8, value)
      end

      def self.element_type()
        Float
      end
    end

    # Array of 32bit floating point numbers.
    # In C++, the type of this array is `arrayof(Float32)`.
    #
    class Float32Array < FFIArray
      # @param [Integer] size  array size.
      # @param [FFI::MemoryPointer] ptr  a memory pointer or nil.
      #   If nil, a new memory block is allocated.
      def initialize(size, ptr=nil)
        if ptr.nil?
          @array = FFI::MemoryPointer.new(:float, size)
        else
          @array = ptr
        end
      end

      def [](index)
        @array.get_float32(index * 4)
      end

      def []=(index, value)
        @array.put_float32(index * 4, value)
      end

      def self.element_type()
        CType::Float32
      end
    end

    # @api private
    # Attaches functions to a module.  The functions are retrieved
    # from the library generated by compiling Ruby methods.
    #
    # @param [Module] module_obj  the module object.
    # @param [Array<String>] method_names  the method name in C.
    # @param [Array<String>] func_names  the function names in C.
    # @param [Array<Type>] method_types  the types of the original methods.
    # @param [String] lib_name  the library name.
    # @param [String] dir  the directory where the library is found.
    # @return [Module] the module object `module_obj`.
    def self.attach(module_obj, method_names, func_names, method_types, lib_name, dir='./')
      module_obj.module_eval('extend FFI::Library')
      module_obj.ffi_lib("#{dir}lib#{lib_name}#{Config::LibExtension}")
      func_names.each_with_index do |fname,i|
        mtype = method_types[i]
        module_obj.attach_function(fname.to_sym,
                                   fname.to_sym,
                                   CFI::param_types(mtype),
                                   CFI::return_type(mtype))
        ivk_name = invoker_name(mtype)
        module_obj.module_eval <<-code, __FILE__, __LINE__
          def self.#{method_names[i]}(*args)
            Yadriggy::Oops::invoke#{ivk_name}(self, :#{fname}, args)
          end
        code
      end
      module_obj
    end

    # @api private
    # Generates a Ruby source file.  When the file is executed,
    # it retrieves functions from the library generated by
    # compiling Ruby methods, and then it attaches the functions
    # to a specified module.
    #
    # @param [String] module_name  the module name.
    # @param [Array<String>] method_names  the method name in C.
    # @param [Array<String>] func_names  the function names in C.
    # @param [Array<Type>] method_types  the types of the original methods.
    # @param [String] lib_name  the library name.
    # @param [String] dir  the directory where the library is found.
    # @return [String] the generated file name.
    def self.make_attach_file(module_name, method_names, func_names, method_types,
                              lib_name, dir='./')
      file_name0 = module_name.gsub(/::|\./, '_').downcase
      file_name = "#{dir}#{file_name0}.rb"
      printer = Yadriggy::FilePrinter.new(file_name)
      printer << "require 'yadriggy/c/ffi'" << :nl << :nl
      printer << "module #{module_name} extend FFI::Library" << :nl
      printer << "  self.ffi_lib(\"#{dir}lib#{lib_name}#{Config::LibExtension}\")" << :nl
      func_names.each_with_index do |fname,i|
        mtype = method_types[i]
        printer << "  self.attach_function(:\"#{fname}\", "
        printer <<     ":\"#{fname}\", "
        printer <<     "#{CFI::param_types(mtype).to_s}, "
        printer <<     ":#{CFI::return_type(mtype)})"
        printer << :nl

        printer << "  def self.#{method_names[i]}(*args)" << :nl
        printer << "    Yadriggy::Oops::invoke#{invoker_name(mtype)}(self, "
        printer <<       ":\"#{fname}\", args)" << :nl
        printer << '  end' << :nl
      end
      printer << 'end' << :nl

      printer.output
      printer.close
      file_name
    end

    # @api private
    def self.invoker_name(mtype)
      case ArrayType.role(MethodType.role(mtype)&.result_type)&.element_type
      when RubyClass::Integer
        '_int'
      when RubyClass::Float
        '_float'
      when CType::Float32Type
        '_float32'
      else
        ''
      end
    end

    # @api private
    def self.invoke_int(module_obj, func_name, args)
      r = invoke(module_obj, func_name, args)
      IntArray.new(0, r)
    end

    # @api private
    def self.invoke_float(module_obj, func_name, args)
      r = invoke(module_obj, func_name, args)
      FloatArray.new(0, r)
    end

    # @api private
    def self.invoke_float32(module_obj, func_name, args)
      r = invoke(module_obj, func_name, args)
      Float32Array.new(0, r)
    end

    # @api private
    def self.invoke(module_obj, func_name, args)
      args2 = args.map do |e|
        if e.is_a?(IntArray) || e.is_a?(FloatArray) || e.is_a?(Float32Array)
          e.memory_pointer
        else
          e
        end
      end
      module_obj.method(func_name).call(*args2)
    end

    # @api private
    # C Function Interface
    module CFI
      def self.param_types(method_type)
        method_type.params.map do |t|
          c_type(t)
        end
      end

      def self.return_type(method_type)
        c_type(method_type.result_type)
      end

      # @param [Type] type
      # @return [String] type name in C.
      def self.c_type_name(type)
        type = type.supertype if InstanceType.role(type)
        if type == RubyClass::Integer || type == Integer
          'int64_t'
        elsif type == RubyClass::Float || type == Float
          'double'
        elsif type == CType::Void
          'void'
        elsif type == RubyClass::String || type == String
          'char*'
        elsif type == CType::Float32Type || type == CType::Float32
          'float'
        else
          at = ArrayType.role(type)
          raise "bad type #{type.inspect}" if at.nil?
          "#{c_type_name(at.element_type)}*"
        end
      end

      # @param [Type] type
      # @return [Symbol] type name for FFI
      def self.c_type(type)
        type = type.supertype if InstanceType.role(type)
        if type == RubyClass::Integer || type == Integer
          :int64
        elsif type == RubyClass::Float || type == Float
          :double
        elsif type == CType::Void
          :void
        elsif type == RubyClass::String || type == String
          :string
        elsif type == CType::Float32Type || type == CType::Float32
          :float
        else
          raise "bad type #{type}" if ArrayType.role(type).nil?
          :pointer
        end
      end
    end
  end
end
